
package com.example.demo;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.LinkedList;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Stack;
import java.util.StringTokenizer;

public class Main{
	
	static PriorityQueue<Integer>[] pquegraph;
	static boolean[] visited;
	static StringBuilder sb;
	
    public static void main(String[] args) throws IOException{
    	BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    	StringTokenizer stn = new StringTokenizer(br.readLine());
    	
    	int vcnt = Integer.parseInt(stn.nextToken());	 
    	int ecnt = Integer.parseInt(stn.nextToken());	 
    	int root = Integer.parseInt(stn.nextToken());	 
    	
    	pquegraph = new PriorityQueue[vcnt+1];
    	pquegraph[0] = new PriorityQueue();
    	for (int i = 1; i < vcnt + 1; i++) {
    		pquegraph[i] = new PriorityQueue();
		}
    	
    	for (int i = 0; i < ecnt; i++) {
    		String[] str = br.readLine().split(" ");
    		int v1 = Integer.parseInt(str[0]);
    		int v2 = Integer.parseInt(str[1]);
    		pquegraph[v1].offer(v2);
    		pquegraph[v2].offer(v1);
		}
    	
    	
    	visited = new boolean[vcnt+1];
		sb = new StringBuilder();
    	sb.append(root).append(" ");
    	dfs(root);
		System.out.print(sb.replace(sb.length()-1, sb.length(), ""));
    	
		System.out.println();
		
//    	visited = new boolean[vcnt+1];
//    	dfs_stack(root);
//    	
    	visited = new boolean[vcnt+1];
		sb = new StringBuilder();
    	sb.append(root).append(" ");
    	bfs(root);
		System.out.print(sb.replace(sb.length()-1, sb.length(), ""));
    	
//    	for (int i = 0; i < result.length; i++) {
//			System.out.println(result[i]);
//		}
    	
    }///
    
    // 1번 돌면서 1만 다 도는게 아니라 1번 정점에서 인접 정점으로 들어가자나 멍청아...
    // 1번에 인접한 정점 다 도는게 아니라 1번의 인접 정점으로 들어가는거라고
    // 그럼 거기서 다시 2번 정점의 인접 정점중 하나로 들어가는거고
    // 지금 혼자 오해한게 1번 인접 정점을 왜 다 안돌지?? 이딴생각하고 있네
    public static void dfs(int root) {
    	visited[root] = true;
    	for(int i : pquegraph[root]) {
    		if (!visited[i]) {
//    			System.out.print(i+" ");
				sb.append(i).append(" ");
    			visited[i] = true;
    			dfs(i);
			}
		}
    }///
    
    public static void dfs_stack(int root) {
    	visited[root] = true;
    	Stack<Integer> st = new Stack<Integer>();
    	st.push(root);		// 왜 담을까?? 	==> 처음에 root부터 시작하기 위해서 root를 담기 위해 하는 것이지 따른 뜻은 없음
    	
    	while(!st.isEmpty()) {
    		int current = st.pop();
    		System.out.println(current);		// 결과값이 거꾸로 뽑히네??
    		for(int i : pquegraph[current]) {	// 인접한 정점들 반복(대신 결고 꼭 root라고해서 root 다 도는게 아니라 인접 정점으로 들어가는 거임 이녀석은 인접 정점들을 다 도는 것이 아니라 스택에 쌓아놓고 다 들어갔다가 나중에 뽑아쓰는 것임)
    			if (!visited[i]) {
					visited[i] = true;
					st.push(i);
				}
    		}
    	}
    	
    	
    	
    }///
    
    public static void bfs(int root) {
    	visited[root] = true;
    	Queue<Integer> que = new LinkedList<Integer>();
    	que.offer(root);	// 왜 담을까??
    	
    	while(!que.isEmpty()) {
    		int current = que.poll();
    		for(int i : pquegraph[current]) {	// 인접한 정점들 반복(이녀석은 인접 정점들을 다 도는 것임 왜냐면 큐로 인해 앞에 쌓고 앞에 바로 뽑아 쓰기 때문에)
    			if (!visited[i]) {
					sb.append(i).append(" ");
//					System.out.print(i+" ");
					visited[i] = true;
					que.offer(i);
				}
    		}
    	}
    	
    }///
    
}/////


----------------------------------------------------------------------------------------------------------
이건 <인접행렬>로 구현한 다른분 코드

import java.io.*;
import java.util.*;

public class Main {
  static int[][] check;
  static boolean[] checked;
  static int n;
  static int m;
  static int start;
  
  public static void main(String[] args) throws IOException {
  Scanner sc = new Scanner(System.in);
  n = sc.nextInt();
  m = sc.nextInt();
  start = sc.nextInt();
  
  check = new int[1001][1001];
  checked = new boolean[1001]; //초기값 False
  
  //간선 연결상태 저장
  for(int i = 0; i < m; i++) {
    int x = sc.nextInt();
    int y = sc.nextInt();
    
    check[x][y] = check[y][x] = 1;
  }
  
  dfs(start); //dfs호출
  
  checked = new boolean[1001]; //확인상태 초기화
  System.out.println(); //줄바꿈
  
  bfs(); //bfs호출
  }
  
  //시작점을 변수로 받아 확인, 출력 후 다음 연결점을 찾아 시작점을 변경하여 재호출
  public static void dfs(int i) {
    checked[i] = true;
    System.out.print(i + " ");
    
    for(int j = 1; j <= n; j++) {
      if(check[i][j] == 1 && checked[j] == false) {
        dfs(j);
      }
    }
  }
  
  public static void bfs() {
    Queue<Integer> queue = new LinkedList<Integer>();
    queue.offer(start); //시작점도 Queue에 넣어야 함
    checked[start] = true;
    System.out.print(start + " ");
    
    //Queue가 빌 때까지 반복. 방문 정점은 확인, 출력 후 Queue에 넣어 순서대로 확인
    while(!queue.isEmpty()) {
      int temp = queue.poll();
      
      for(int j = 1; j <= n; j++) {
        if(check[temp][j] == 1 && checked[j] == false) {
          queue.offer(j);
          checked[j] = true;
          System.out.print(j + " ");
        }
      }
    }
  }
}
